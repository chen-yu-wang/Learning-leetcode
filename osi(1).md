## 协议层次及他们的服务类型

### OSI七层模型 

物联网叔会试用 = 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

① 物理层：

​	实现计算机节点之间的**比特流**的透明传送，向上层屏蔽掉传输介质与物理设备的差异，使数据链路层不必考虑网络的具体传输介质是什么。

②数据链路层

​	**两台主机间的数据传输，总要在一段段的链路上传送**。数据链路层将网络层交付的IP数据报**组装成帧**，在相邻节点间的链路上传输帧。帧包括数据以及控制信息：通过控制信息我们可以得知每一帧的起止比特位置，以及检测收到的帧有无差错。

③网络层

​	两台主机间传输数据时，其通信链路往往不止一条，传送的信息可能经过很多通信子网，网络层的主要任务就是**选择合适的网间路由与交换节点**。网络层又叫IP层，使用无连接的网际协议与许多路由协议。

④传输层

​	传输层的主要任务就是为两台主机**进程**之间的通信提供服务。应用程序利用该服务传送应用层报文。由于主机可同时运行多个**线程**，因此传输层有**分用和复用**的功能(复用：多个应用层进程同时使用传输层服务，分用：收到的信息分别交付给应用层的某个进程)。

⑤会话层

​	负责建立、管理与终止表示层实体间的通信会话。

⑥表示层

​	数据压缩、数据加密与数据描述。

⑦应用层

​	通过**应用程序**之间的交互实现特定的网络应用，应用层协议定义了应用进程之间的交互规则，**通过不同的应用层协议为不同的网络应用提供服务**，如域名系统DNS、支持万维网应用的HTTP协议、email采用的SMTP协议。

### TCP/IP参考模型

<img src="https://pic.leetcode-cn.com/1612150605-NindRH-image.png" alt="image.png" style="zoom: 50%;" />

① 网络接入层：对应于OSI中的物理层与数据链路层。负责监**视数据在主机与网络间**的交换。**TCP/IP并未真正描述这一层的实现，而是由参与互联的各网络使用自己的物理层与数据链路层协议，然后与TCP/IP网络接入层进行连接。**

②网际互联层：对应OSI的网络层，负责相同或不同网络中**计算机间的通信**

③传输层：TCP、UDP

④应用层：OSI中最上三层合并。

### OSI 模型和 TCP/IP 模型异同比较

(1)相同点：都分层、都提供有连接与无连接通信服务机制。

(2)不同点：

​	①OSI是先有模型，后有协议规范，适用于各类网络；TCP/IP是先有协议集再建立模型，不适用于非TCP/IP网络。

​	②TCP/IP没有对网络接口层进行细分，只做概念性描述；OSI对服务与协议作了明确区分。

| OSI 七层网络模型        | TCP/IP 四层概念模型 | 对应的网络协议                                      |
| ----------------------- | ------------------- | --------------------------------------------------- |
| 应用层（Application）   | 应用层              | HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP |
| 表示层(Presentation)    | -                   | TIFF, GIF, JPEG, PICT                               |
| 会话层（Session）       | -                   | RPC, SQL, NFS, NetBIOS, names, AppleTalk            |
| 传输层（Transport）     | 传输层              | TCP, UDP                                            |
| 网络层（Network）       | 网络层              | IP, ICMP, ARP, RARP, RIP, IPX                       |
| 数据链路层（Data Link） | 数据链路层          | FDDI, Frame Relay, HDLC, SLIP, PPP                  |
| 物理层（Physical）      | -                   | EIA/TIA-232, EIA/TIA-499, V.35, 802.3               |

### 为什么 TCP/IP 去除了表示层和会话层

OSI是先提出的一种概念模型，想法是好的，但是实际上，由于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，无法实现代码上的抽象共享。

### 数据如何在各层之间传输【数据的封装过程】

应用数据报→传输层报文段→ip成组→链路层成帧→物理层比特流

## 物理层

### 物理层作用

利用传输介质为通信的两端建立、管理和释放物理连接；实现**比特流的透明传输**

### 主机间通信方式

(1)单工通信：发送方和接收方是**固定的**，消息只能**单向传输**

(2)半双工通信：通信双方都可以发送消息，但**同一时刻同一信道只允许单方面发送数据**，如对讲机。

(3)全双工通信：允许通信双方同时在两个方向上传输，如打电话。

## 数据链路层

### MAC 地址和 IP 地址分别有什么作用

MAC是数据链路层和物理层使用的地址，是写在网卡上的物理地址，**用来定义网络设备的位置**

IP地址是网络层及以上各层使用的地址，是一种**逻辑地址**，用来区分网络上的计算机

### 为什么有了MAC 地址还需要IP 地址？

只有MAC地址的话，寻址困难(需要每个路由器记住2^48个MAC地址)

IP地址和地域有关，可以分区域找到其所属子网，效率高。

### 为什么有了IP地址还需要MAC 地址？

只有当**设备接入网络后才能知道他所处哪个子网，为其分配IP地址**。在设备接入网络时我们需要MAC来区分不同设备。

## 网络层

### IP 协议的定义和作用

IP协议提供无连接的不可靠的数据传输服务，其作用是：

​	(1)**寻址和路由**，每个IP数据包会携带源IP地址和目的IP地址，每个中间节点根据网络地址进行转发

​	(2)**分段与重组**：IP协议给每个数据包分配一个标识符与分段重组相关信息，使得数据包可以在不同的网络中分段独立传输，到达目的地之后再重组。

### 路由器和交换机的区别(hub、交换机、网桥、路由器？)

(1)集线器hub，工作在物理层，更大的冲突域

<img src="pic\搜狗截图20211021201834.jpg" alt="搜狗截图20211021201834" style="zoom: 80%;" />

(2)交换机，工作在**数据链路层**，负责转发数据包(**依据MAC地址**)

(3)网桥，工作在数据链路层，以MAC地址为标识转发数据包

(4)路由器，工作在物理层，依据数据包中的目的IP地址，按照路由选择协议与路由表信息确定转发路径

### ICMP 协议概念/作用、应用

(1)ICMP，因特网控制报文协议，用来实现IP协议中未实现的功能

(2)ICMP**不传输数据，只传输控制信息用来辅助网络层通信**，主要功能是**验证网络是否畅通**(对方是否成功收到IP数据包)，与**辅助IP协议可靠传输**(若发生IP丢包，ICMP会通知发送方丢包原因)

(1)应用：

​	①PING

​	②TraceRoute，测路径与到达每个路由器的往返时间

### ARP 地址解析协议

IP地址通过ARP协议转换为物理地址(硬件地址)，为解决同一局域网内IP地址与MAC地址映射的问题

RARP将MAC地址转为IP地址

### 网络地址转换 NAT

(1)为解决公共IP地址紧缺的问题，NAT提供把内部私有网络地址翻译成公有网络 IP 地址的功能，此外NAT还可以隐藏和保护网络内部主机。

(2)实现方式主要有三种：

​	①静态转换：内部IP和外部IP一对一，不会改变，但当某一公有IP被占用时，和该IP绑定的内网IP将会无法联网。

​	②动态转换：每次转化的公有IP是不唯一的

​	③端口多路复用

### IPV4 地址不够如何解决

(1)DHCP：动态主机配置协议,在**应用层**，动态分配 IP 地址，**只给接入网络的设备分配IP地址**

(2)CIDR：无分类编制，/斜杠记法，只能更有效分配IPV4空间，无法根本解决

(3)NAT：网络地址转换协议，**不同局域网的主机可以使用相同IP(因为局域网内部主机箱和外界通信时会NAT转为全球IP)**

(4)IPV6

## 传输层

### 三次握手和四次挥手机制

![image.png](https://pic.leetcode-cn.com/1614160878-FiFlkq-image.png)

**三次握手：**

首先，client和server分别结束CLOSE阶段，server进入Listen阶段。

①client发送SYN包，标志位SYN=1,序列号seq = x，随后client进入SYN-SENT阶段

②server收到SYN包，结束Listen阶段；随后向client发送一段报文，

​	标志位SYN = 1, ACK = 1,表示确认client的序列号seq有效，服务器正常、

​	序列号 seq = y 

​	确认号 ack = x+1 ，表示确认收到客户端seq并+1作为自己的确认号ack值，随后进入SYN-RECV阶段。

③client收到了SYN+ACK包后，结束 SYN-SENT阶段，并返回一段报文

​	标志位为ACK，表示确认收到服务器同意连接的信号

​	序列号 seq = x+1，表示确认收到了服务器端序号ack，将其+1作为自己的seq

​	确认号ack = y+1，表示收到了服务器端的序列号seq，将其+1作为自己的ack

​	随后客户端进入ESTABLISHED阶段

服务器端收到客户端发送的ACK报文后，结束SYN-SENT阶段，进入ESTABLISHED阶段

**总结：**

1向2发送 SYN包，seq = x

2回复1 SYN ACK包，seq = y，ack = x+1

1发给2 ACK包，seq = x+1，ack = y+1

**四次挥手**

<img src="https://pic.leetcode-cn.com/1612459478-ajInIu-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手.png" style="zoom: 50%;" />

①首先client向server发送FIN报文表明要释放TCP链接

​	标志位FIN ，表示请求释放

​	序列号seq = u

​	随后客户端进入FIN-WAIT-1阶段

②server收到FIN包后，结束ESTABLISHED阶段，进入CLOSE-WAIT阶段并返回ACK包

​	标志位ACK，表示收到了客户端释放链接的请求

​	序列号seq = v

​	确认号ack = u+1

​	随后服务端开始准备释放服务端到客户端方向的连接

客户端收到服务端的ACK包后，结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

③服务器端发送ACK包后，会等待遗留数据传输完毕后，再向client发送一段FIN ACK包：
	标志位FIN ACK，表示做好释放链接的准备

​	序号seq = w

​	确认号ack = u+1

​	随后，server会结束CLOSE-WAIT阶段，进入LAST-ACK阶段，并停止发送数据

④client收到FIN ACK包后，确认服务器做好了释放链接的准备，便结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器发送ACK包

​	标志位ACK，表示收到了服务器准备好释放链接的信号

​	序列号seq = u+1

​	确认号 ack = w+1

**随后客户端在TIME--WAIT阶段等待2MSL**，而服务器端收到客户端的FIN ACK之后便进入CLOSED阶段，正式关闭服务器端到客户端方向的连接。待客户端等待完2MSL后，结束TIME-WAIT，进入CLOSED阶段。

### 如果三次握手的时候每次握手信息对方没有收到会怎么样

![image.png](https://pic.leetcode-cn.com/1627570368-YNpFKD-image.png)

### 为什么要进行三次握手？两次握手可以吗？

三次握手可以保证通信双方都是双工通信：

​	第一次握手，server确认client发送功能正常

​	第二次握手，client确认server收发功能正常

​	第三次握手，server确认client接收功能正常

如果没有第三次握手告诉服务器**客户端能否收到服务器传输的数据**的话，服务器端的端口就会一直开着

### 为什么要四次挥手？

TCP是全双工的，两个方向的连接需要单独关闭。

当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。待被动方传输完数据后，再释放。

### CLOSE-WAIT 和 TIME-WAIT 的状态和意义

(1)CLOSE-WAIT: 当server收到client的关闭连接请求，并做出答复后，进入CLOSE-WAIT阶段，CLOSE-WAIT的意义就是为了**保证服务器在关闭连接之前将待发送的数据发送完成**。

(2)TIME-CLOSE: **第四次挥手后,客户端进入的状态,是客户端必要的等待时间**

​	如果没有这个阶段的话，会出现两个问题：

​	①客户端立即关闭后，立即使用相同端口握手并坚立通信，此时上次连接残留的数据包会被误认为是本次的，造成数据异常

​	②客户端直接关闭后，若server重新发送FIN包，客户端会回应RST报告异常，但其实是没有异常的。

### TIME_WAIT 状态会导致什么问题，怎么解决

**高并发短连接**的应用场景下，当服务器端处理完后主动请求释放连接，则server段会有大量连接处于TIME-WAIT阶段，可能导致后续连接失败

解决办法：修改或者配置SO_REUSEADDR套接字，使TIME-WAIT接口可以快速回收

### TIME-WAIT 为什么是 2MSL

(1)首先了解一下**MSL：报文最大生存时间**

​	TTL ：生存时间（跳数）

​	RTT ：客户到服务器往返所花时间

(2)客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。

因为若**服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文，再次向客户端发出 FIN 报文**,FIN报文生存时间是MSL，加起来是2MSL

### TCP 和 UDP 的区别

![搜狗截图20211022205643](pic\搜狗截图20211022205643.jpg)

### TCP 是如何保证可靠性的

(1)**序列号和确认应答**： TCP给发送的每个包进行编号，接收方收到数据后会进行应答发送ACK报文

(2)**校验和**：检测数据在传输过程中的变化，若接收到的报文校验和由差错，即丢弃

(3)**流量控制**

(4)**拥塞控制**

(5)**超时重传**： TCP发出一个报文段后，启动一个定时器，等待目的端确认接收到这个报文段。若超过某个时间还没有收到确认，则重发这个报文段

(6)连接管理：三次握手四次挥手

### TCP 流量控制

利用**滑动窗口机制**在TCP连接上实现流量控制

(1)发送窗口：

​	①未收到确认报文，发送窗口前后沿都不移动

​	②收到确认报文，发送窗口后沿前移，前沿依据确认报文段中的接收窗口调整

(2)接收窗口：

​	接收方依据接收缓存的使用情况，动态调整接收窗口的大 小，通过确认报文段告知发送方

​		——**发送窗口受接收窗口控制**

### TCP 拥塞控制

![image.png](https://pic.leetcode-cn.com/1618208921-kuMbas-image.png)

## 应用层

### HTTP 头部包含哪些信息

HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。

(1)通用头部：client和server都可使用的头部，可在client、server和其他应用程序间提供些非常有用的通用功能，如Date头部

(2)请求头部：请求报文特有，为服务器提供一些额外信息，如Accept头部

(3)响应头部：便于客户端提供信息，如server头部

(4)实体头部：请求/响应报文中实体部分的首部；

