## **1.   操作系统概论**

### 1.4.1 作业和进程

**作业（job）： **

请求计算机完成的一个完整的处理任务称为作业，它可以包括几个程序的相继执行

**进程（process）：**

是操作系统中最重要的概念之一，目前对UNIX系统上的进程定义为**程序在一个数据集合上的运行活动**，它是**系统进行资源分配和调度的一个可并发执行的独立单位**。

   进程和程序之间既有区别又有联系： 

•  **进程是程序执行的动态活动**，它是暂时地动态地产生和终止的，

•  程序是进程运行的静态文本，它可以长期保存。

•  一个进程可以执行一个或多个程序，反之，同一个程序也可被多个进程同时执行。

### 1.4.2 操作系统的特征

**并发（Concurrence）** 
          在某一时间间隔内计算机系统内存在着多个程序活动（与并行的区别）。
**共享（Sharing）** 
          多个用户或程序共享系统的硬、软件资源。
          互斥共享和同时共享 

**虚拟**
    	在原先的物理机器上覆盖了一至多层系统软件，将其改造成一台功能更强大而且易于使用的扩展机或虚拟		机。提供了高级的抽象服务。  

**不确定性**

​	    使用同样一个数据集的同一个程序在同样的计算机环境下运行，每次执行的顺序和所需的时间都不相同。

​		原因:

​				由于多道程序环境下的操作系统系统内活跃作业数量的变化及它们之间复杂的联系、程序的输入输出			请求、从外部设备发出的中断等大量事件发生的时间都是**不可预测的**，外部设备的速度也存在细微的不			确定的变化，因此，作**业就在不可预测的次序中前进**，即程序的执行过程是不可预测的。

### 1.4.2 操作系统的功能

**1.处理机管理** 
          主要是进程管理，调度。同步互斥、死锁等

**存储管理**

​		为运行的作业分配内存空间以及运行结束时的回收，还负责作业在内存部分与外存部分的交换

**设备管理**

​		负责设备的分配与回收，设备的控制与信息传输(设备驱动)

**文件管理**

​		文件存储空间的分配与回收、目录管理、映像等

### 1.5.3 UNIX系统基本结构★★★

| **Shell  解释程序**                                        |
| ---------------------------------------------------------- |
| **用户程序 各种应用程序包       系统命令 窗口软件 库函数** |
| **系统调用**                                               |
| **核心层：     存储管理  进程管理  设备管理  文件管理**    |
| **硬件层**                                                 |

## **2.   存储管理**

### 2.1 存储管理基础★★

![image-20210621163154028](C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210621163154028.png)

**①固定定位方式**

**②静态重定位**

​		源程序经编译和连接后生成的目标代码中的地址是以0为起始地址的相对地址，需要执行时，**由装入程序自动运行重定位模块**，自动叠加一个基地地址，**修改所有有关地址部分的值**。

​		必须要给作业分配连续的存储区域，作业执行期间不能扩充存储空间。

**③动态重定位**

​		MR = BR + VR

​		程序装入内存时，不必修改程序的逻辑地址，而是在程序执行期间访问内存钱实时的进行映射。

​		不必给作业分配连续的存储区域。

### 2.3.1 空闲存储区表★★★

​		可变分区存储管理法并不预先将内存划分成分区，而是等到作业运行需要内存时就向系统申请，从空闲的内存区中“挖”一块出来，其大小等于作业所需内存大小，这样就不会产生“内零头”。

```
struct map {    
        unsigned m_size;// 空闲分区的长度
        char *m_addr;	// 空闲区的起始地址
 };
struct map coremap[N];
各个空闲分区按起始地址由低到高顺次登记在空闲存储区表中。
m_size为0的表项是空白表目项，它们集中在表的后部。
```

### 2.3.1 首次适应法★★★

​		采用首次适应法为作业分配大小为size的内存空间时，**总是从表的始端的低地址部分开始查找。**

​		当第一次找到大于或等于申请大小的空闲区时，就按所需大小分配给作业。

​		如果分配后原空闲区还有剩余空间，就修改原存储区表项的m_size和m_addr，使它记录余下的“零头”。

​		如果作业所需空间正好等于该空闲区大小，那么该空闲区表项的m_size就成为0。

​		接下来要删除表中这个“空洞”，即将随后的各非零表项依次上移一个位置。

### 2.7 段式存储管理★★

​		段式存储管理系统中，用户可以根据逻辑结构将**程序分成若干段**，每一段的虚地址空间各自都从0开始编址。

​		其意义在于保留程序的模块化结构，**程序装入内存可不连续。**

### 2.8 段页式存储管理★★

​		段页式存储管理的基本思想是将面向用户的程序地址空间分为段，系统为每一段分配和管理实存时再分页。

​		段页式存储管理系统的逻辑地址可分成三个部分：段号p、页号s、页内偏移d

​		系统为每一个作业建立一张段表，再为每一段建立一张页表。同样，也有一个段表控制寄存器，存放当前作业段表的长度和始址。

地址变换：

​	（1）在段表控制寄存器中获得当前运行作业的段表始址；

​	（2）将段表始址与虚地址字中的段号（要扩大段表项长度因子）相加，得到访问段在段表中的表项地址；
​	（3）从段表的表目项中获得该段的页表始址，并将其与虚地址字中的页号p相加，得到当前访问页的页表项地址；
​	（4）从页表表项中得到页架号,并与虚地址字中的页内偏移拼成主存物理地址，装入地址寄存器MA；
​	（5）根据地址寄存器中地址值访问内存。

## **3.   进程管理**

### 3.1 进程概述★★★

​		3.1.1进程是**程序处于一个执行环境中在一个数据集上的运行过程**，它是**系统进行资源分配和调度的一个可并发执行的独立单位**。

​		一个进程可以执行一个或多个程序。

​		同一程序也可被多个进程同时执行。

​		**3.1.2进程的组成：**

​				**共享正文段**

​					共享正文段是可以被多个进程并发地执行的代码，由不可修改的代码和常数部分组成

​				**进程控制块**

​					PCB是系统用于查询和控制进程运行的档案，它描述进程的特征，记载进程的历史，决定进程的命				运

​					分类：

​							**进程基本控制块**：常驻内存

​							**进程扩充控制块**：进程不处于执行状态时，os便不访问。可以换入换出。

​				**数据区**

​							进程执行时用到的数据

​				**工作区**

​							**核心栈**——进程在核心态运行时的工作区。

​							**用户栈**——进程在用户态下运行时的工作区。

​		**3.1.3进程状态**

​		**<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210621215739986.png" alt="image-20210621215739986" style="zoom:33%;" />**

### 3.2 进程控制块★★★

​	**UNIX中，常驻内存的进程PCB是proc结构**

```
struct proc{
	short p_addr           相应user结构的起始页面号
	struct text *p_textp   指向共享正文段结构的指针
}
```

​	**非常驻内存的PCB是进程控制扩充块user结构**

```
struct user {
 	struct proc *u_procp；	/* 指向相应proc结构的指针 */
}
```

​	**对于每个正在使用的共享正文段，系统分配一个控制块text结构**

```
struct text	 {
   short	x_daddr；	    /* 正文段在盘交换区地址 */
   struct  proc *x_caddr；	/* 指向链接的proc结构 */
   struct  inode *x_iptr；	/* 指向正文段所在文件的内存索引节点的指针 */
}
```

​		下图是进程映像的基本结构，其中**共享正文段、数据段、用户栈段位于用户态地址空间**，其他部分位于核心态地址空间

​		<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210621224852245.png" alt="image-20210621224852245" style="zoom:80%;" />

​		PCB的组织方式：**链式方式，将不同状态的进程链接成就绪队列、阻塞队列等**，还可以继续细分。

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210621225405484.png" alt="image-20210621225405484" style="zoom:80%;" />

### 3.4.1 进程的切换调度算法★★

1. **UNIX的切换调度策略**
    采用**动态优先权算法**：在一个适当的时机，选择一个优先权最高，也即**优先数（p_pri）最小**的**就绪进程**，使其占用处理机。
    进程可以处于两种运行状态，即用户态和核心态。
    **系统对在用户态下运行的进程，可以根据优先数的大小，对它们进行切换调度**。
    对在**核心态下运行的进程，一般不会对它们进行切换调度**，即UNIX核心本质上是不可重入的。 

2. **优先数的计算**

  **用户态的进程**，核心在适当时机用下列公式计算进程的优先数：
  			**p_pri = p_cpu/2 + p_nice + PUSER + NZERO**
  p_cpu是进程占用处理机的量度，**每次时钟中断，使当前执行进程的p_cpu加1**，但最多加到80；**每1秒钟使所有就绪状态进程的p_cpu衰减一半**。以形成一个负反馈的过程，使用户态的诸进程能比较均衡地使用处理机。
  **p_nice是用户设置的进程优先数偏置值。**
  PUSER和NZERO是两个常量，用于分界不同类型的优先数。 

3. **优先数的设置**

  核心态运行的进程不会被强迫剥夺处理机。只有在其因等待系统资源等原因进入睡眠状态时，系统才会给其分配一个事件相关的优先数。在其被唤醒后，才以设置的优先数参与竞争处理机。

4. **进程切换调度的时机**

  **进程自愿放弃处理机而引起切换调度**：
  		进程完成了预定任务；
  		进程因等待某种资源进入了睡眠状态；
  		进程因同步或互斥的需要，暂停执行。
  **系统发现可能更适合占用处理机的进程**，**设置了强迫调度标志runrun**：
  		在唤醒睡眠进程时，发现该进程的优先数小于现运行进程。
  		进程由系统调用返回用户态时，重新计算自己的优先数，发现自己的优先数上升了。
  		在时钟中断程序中每一秒对所有优先数大于（PUSER-NZERO）的进程（一般原先在用户态下运行）重	新计算优先数，通常总要设置runrun标志。 

### 3.4.2 切换调度程序-(主要任务)★★★

 		**保存现运行进程的现场信息**；
 		 在就绪队列中**选择一个在内存且优先数p_pri 最小的进程**，**使其占用处理机**，如找不到这样的进程，机器就空转等待；
 		 **为新选中的进程恢复现场**。

### 3.4.3 进程的对换调度★★

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622103659533.png" alt="image-20210622103659533" style="zoom:80%;" />

### 3.6.1 进程的创建——fork()例子★★★

​	UNIX采用了在**调用创建子进程的系统调用后，使父子进程具有不同的返回值**，这样就可以采用**判断语句**，使父子进程可以执行不同的程序段，以便完成不同的任务。

​		在执行系统调用**fork后，父进程得到的返回值是所创建子进程的标识数，而子进程的返回值为0**。下面是一个使用系统调用fork的简例

```
main()
{
    int pid;
    printf(“Before fork\n”);
    while((pid=fork())==-1);
    if (pid) {   
	   printf (“Parent process: PID= %d\n”, getpid());
	   printf “Produced child’s PID= %d\n”, pid);
    } else {
   		 printf (“Child process: PID= %d\n”, getpid());
    }
    printf(“Parent or child process: 
				PID= %d\n”,getpid());
}
```

### 3.6.2 进程图像的改换——execl()例子★★★

​		exec的调用进程用一个可执行文件中的程序和数据**取代**当前正在运行的程序和数据，从而使主调进程的图像改换成新的图像。

​		尽管新执行的程序与原进程的执行程序完全不同，但**该调用并不形成新进程**，因为原进程的proc结构和user结构并不改换，其进程标识数p_pid与主调进程相同，与父进程的关系也没有改变。 

​		**execl()用于装入一个带路径的可执行文件，用新程序覆盖老程序，然后运行这个新程序，老进程。**

​		**execl()调用实例**如下，其中父进程将status初值置1是为了和子进程的返回值相比较：

​				当execl()调用成功时，返回值status由ls程序设置

​				只有当exec调用失败后才执行后面的printf和exit(2)语句，返回的status高8位置2

```
main()
{
   int   i，pid，status = 1；
   printf (“Before fork call.\n”)；
   while ((i=fork( ))==-1)；
   if (i) {                /* 父进程 */
       printf (“It is the parent process.\n”)；
       pid =wait (&status)；						/*挂起等待子进程*/
       printf (“Child process %d，status =%d \n”，pid，status)；
   } else {             /* 子进程 */
       printf (“It is the child process.\n”)；
       execl (“/bin/ls”，”ls”，”-l”，(char*)0)；  /* 映象改换 */
       											/*成功后子进程立即结束，不执行后续代码*/
       printf (“execl  error.\n”)；              /* 映象改换失败 */
       exit (2)；
   }
   printf (“Parent process finish. \n”)；
}

```

### 3.7.1 进程和线程★★

​	在进程的概述一节中谈到**进程包含了下列两个特征**：

​		**资源拥有单位**：进程的虚址空间用于驻留进程的图像，进程可以分配到主存和控制其它的系统资源。
​		**调度单位**：进程是可以并发执行的独立单元，是操作系统进行调度的一个实体。
​	大多数操作系统把这两个特征看成不可分割的，是一个进程的基本特征，但实际上这两个特征是独立的。
​	近年来开发的一些操作系统区别了这两个特征，并创建了**一种新的调度和执行的实体单元——线程**，也可称轻量级进程，而原先的资源拥有单位通常还是称为进程或任务。

​		**进程：资源分配**

​		**线程：调度与执行**

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622113156358.png" alt="image-20210622113156358" style="zoom: 67%;" />

## **4.   进程通信**

### 4.3 信号灯和Wait、Signal操作

​		信号量定义成具有**整型值**，并能对其施加以下三种操作的变量，除了这三种操作之外的任何操作都不能测试和处理信号量的值。

​		（1）初始化操作，信号量能初始化为非负的值。
​		（2）**semWait操作，能减小信号量的值**，如**结果值为负，执行semWait操作的进程就被封锁**。
​		（3）**semSignal操作，能增加信号量的值**，如果结**果值非正，那么原先因执行semWait操作而阻塞的进程被解除阻塞**

### 4.4 信号的的应用★★★

#### 	4.4.1 利用信号量实现互斥

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622191720000.png" alt="image-20210622191720000" style="zoom:67%;" />

	信号量的所有可能取值及意义为：
		s = 1	   无进程进入临界段
	        0	   有一进程进入临界段
	       -1	   有一进程进入临界段，另一进程被阻塞
	       如有n个并发进程涉及一个临界段，则上式最后一行s的取值为i， -(n-1) ≤i≤-1，表示当前有|i|个进程被		阻塞。
#### 	4.4.2 阻塞/唤醒协议

​		进程是并发异步运行的，想要成功协同工作，需要在某些点上同步活动。

​		阻塞/唤醒协议可以通过对某一信号量的semWait、semSignal操作控制两个进程间的执行顺序。如当进程需要等待相关的协同进程共同完成某一任务时，**可以对初值0的信号量s执行semWait，使自己在此点阻塞**。等待**另一进程完成相关操作并执行semSignal操作后，原阻塞进程被唤醒。此为半同步。**

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622192507891.png" alt="image-20210622192507891" style="zoom:67%;" />

#### 	4.4.3 两个进程间的同步

​		设有两个进程Pa和Pb。进程Pa每次执行一个计算，并将结果存入一个缓冲区；进程Pb则从缓冲区中取出结果，并将结果打印出来。
​		为了**实现计算进程和打印进程之间的相互同步，就需要设置2个信号量S1和S2**。
  	  在semWait、semSignal操作之前两个信号量的含义为：

​					**S1表示缓冲区中是否已存入进程Pa的计算结果，**也即通知进程Pb是否可取出缓冲区中的信息并送往				打印机。
  						S1值为：
​    								0：Pa没存入新的计算结果
​    								1：Pa已存入新的计算结果
​    				**S2：表示缓冲区中的结果是否已被进程Pb取去**，也即通知进程Pa是否可将新的计算结果再存入缓冲				区。
​    					S2的值为：
​    								0：Pb没取走缓冲区中的数据，缓冲区满

####     								1：Pb已取走缓冲区中的数据，缓冲区空

​					**信号量的初值可设置为：**
   					  **S1为0：缓冲区还未存入数据**
 						**S2为1：缓冲空闲（相当于Pb已取走数据）**

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622193641918.png" alt="image-20210622193641918" style="zoom:67%;" />

#### 	4.4.4 生产者和消费者问题

​			生产者和消费者问题是通过有限的缓冲区（仓库）将一群生产者P1, P2…Pk和一群消费者C1,C2…Cm联系		起来。可设信号量

​					**buffers的初值为n，表示空闲的缓冲区数目。**
​					**products的初值为0，表示已存入缓冲区的产品数目。**

​					**mutex，由于存放产品的缓冲区本身是一种临界结构，也是临界资源。**

​			生产者和消费者问题的一般过程为：

​				**生产者在执行semWait(buffers)之后，只要buffers≥0(还有空闲的缓冲区)，就可将产品送入**。

​				**消费者在执行semWait(products)后，只要products≥0(产品还未取完)，就可以从缓冲区中取走产			品并消费之。否则，生产者或消费者进程就被阻塞**。

<img src="C:\Users\asus-pc\AppData\Roaming\Typora\typora-user-images\image-20210622194758704.png" alt="image-20210622194758704" style="zoom:67%;" />

​			**仔细推敲semWait、semSignal操作的次序。这些操作的次序安排得不合理，就有可能发生“死锁”。**		**如：**

​				semWait(mutex)操作放在semWait(buffers)和semWait(products)之前，当生产者进程通过了semW

​			ait(mutex)，但是在此期间其他生产者把buffer占用光了，导致没有空闲缓冲区，就会出现死锁。	

### 4.4.5 读者/写者问题★★★

​		当有读进程正在访问数据对象时，读进程的个数与互斥要求没有关系。只有当第一个读进程需要对数据对象访问时，才需要执行semWait操作，以判断是否有写进程正在更新数据对象。
​		只有当最后一个读进程退出访问数据对象的临界段时，才需要执行semSignal操作，以便拆除“路障”，让一个写进程进入。
​		需要设置一个跟踪正在临界段访问数据对象的读进程个数的全局共享变量count。由于该计数器也是一个临界资源，所以诸进程对它的访问也应当互斥地进行，为此，还要设置另外一个互斥信号量。

```
信号量初值：mutex 为1
          wrt为1
计数器变量：int count = 0 
writors: 
while ( )  { 
		semWait(wrt); 
		write  information 
		semSignal(wrt); 
} 
readers:
while ( )	{  
	   semWait(mutex);	
      if( ++count == 1)
		   semWait(wrt);
	   semSignal(mutex);	
	   Read information;
       semWait(mutex);
       if ( --count == 0 )
    	    semSignal(wrt);
	    semSignal(mutex);
	}
```

### 4.6.3 信号的传送，程序例子★★★	

​	利用信号实施进程间通信的主要方式是使用**系统调用kill（pid，sig**），其功能是**将信号sig传送给由参数pid限定的进程**。当：
 		 **pid为正值时，对应于一个有效的进程标识数，该信号就发送给这个唯一的进程**。
 		 pid为0时，将信号发送给受同一终端控制的所有进程。
  		pid为-1时，将信号发送给与发送进程用户标识数相同的所有进程。
  		pid < -1时，将信号发送给组标识数为pid的绝对值的所有进程。

```
# include  <sys/types.h>
# include  <signal.h>
main ( )
{
int status；
pid_t pid；
void func ( )；
signal (SIGUSR1,func)；1  /* 预置信号处理程序 */
if  (pid=fork () ) {	        2
   	      printf ("Parent: will send signal.\n")；4
   	      kill (pid, SIGUSR1)；    5	/* 发送信号 */
   	      wait (& status)；            6	/* 等待子进程停止 */
   	      printf ("status=%d: Parent finish:\n"，status)；10
    	 } else {
   	      sleep (10)；            3	/* 等待接受信号 */
   	      printf ("Child：signal is received.\n")；8
   	      exit (0)；				     9
         	}
 }
```



### 4.7.1 产生死锁的原因★★★

​		当两个进程各占了对方所要的一个资源，就会形成死锁		

### 4.7.2 产生死锁的条件 ★★★

​		同时具备下列**三个静态的必要条件时，才有可能产生死锁**。

​			 (1) **互斥执行**    每次只能允许一个进程占有和使用一个资源，其他申请该资源的进程被阻塞。
​		 	(2) **保持并等待**    当进程等待分配给它新的资源时，保持占有已分配的资源。
​			 (3) **不可剥夺**    不能强迫移去进程占有的未使用完的资源。
 		上述这三个条件是产生死锁的必要条件，但即使存在全部这三个条件也不一定会发生死锁。要**产生死锁必须存在第四个动态条件**：
​		(4) **循环等待    存在一个闭合的进程──资源链，以致每一个进程至少占有链中下一个进程所需要的一个资源**

### 4.7.3 死锁的预防★★★

​		所谓预防死锁，就是在设计系统时，使系统能预先排除死锁的可能性。预防死锁有两种方式，一是间接方法，即从前三个静态必要条件(互斥执行、保存并等待、不可剥夺)中选择一个避免其发生即可；二是直接方法，避免发生循环等待条件 即可：

​		1．互斥执行

​				一般说来，第一个条件是不能排除的。

​		2.保持并等待

​				可以预防，只要一次性申请需要的所有资源，在所有资源满足前阻塞自己

​		3.不可剥夺

​				一个方法是，如**占有某些资源的进程不能获得进一步的资源，该进程必须释放原先所占有的资源**；如			果需要，以后再申请这些资源

​				另外的方法是，**如果一个进程需要申请当前正被其他进程占用的资源，操作系统就要求后者释放它所			占用的这类资源**。这种预防死锁的方法只能用在后申请资源的进程优先级较高的情况下、

​		4.循环等待

​				采用**有序资源使用法**可以防止循环等待条件。如果一个进程已经分配了类型R的资源，那么以后它只能			申请在资源顺序表中排在R后面的资源类型

### 4.7.4 死锁的避免，银行家算法★★★

​		避免死锁主要有以下两个判断和处理时机：

​			**(1) 进程启动时判断**    

​					**如果对资源的要求会导致死锁，就不启动有关进程**。这种方法仅仅在当前所有进程对资源的最大请				求加上启动进程对资源的请求都满足的情况下，才能启动新进程，故这种避免死锁的策略不会是最优				的，因为它假定的是最坏情况，即所有进程都同时需要最大数量的资源。
​			**(2) 资源分配时判断**    

​					如果对资源的分配会导致死锁，就暂不允许进一步为进程分配资源。	

​			**银行家算法**：

​				**分配资源时，申请者要把同类资源的最大需求量告诉系统，如系统现存的可用资源数能满足申请者剩			余需求量时，就满足当前的部分或全部申请，否则就推迟分配**。

​				这样**至少保证有申请者能得到所需的全部资源**，可执行到结束，然后释放资源供别的申请者使用。
​				**如果系统保证申请者在有限的时间内能获得所需的全部资源，则称系统处于安全状态**，否则称系统处			于不安全状态，并有可能引起死锁。银行家算法是在能确保系统处于安全状态时才把资源分配给申请			者。

## **5.   设备管理**

### 5.6 磁盘调度

​		磁盘一般用于文件存储，盘上信息的地址是多重编址的，包括驱动器号、面号、道号、扇区号。

​			存取盘块中信息的时间：
​				寻道时间  100ms
​				等待时间  10ms
​				传送时间  1ms

​			磁盘调度算法：

​				先来先服务调度（FCFS）
​				最短寻道时间优先法（SSTF）

​				扫描法(SCAN C-SCAN，前者正反正反，后者正正正)

​		独立磁盘冗余阵列RAID

​			RAID1:

​				通过复制所有数据来实现冗余

​				读请求可以从任何一个磁盘获取服务，效率*2；

​				写请求需要对两个磁盘都更新

​				故障恢复简单，只需要复制即可

​			RAID4：

​				对每个数据磁盘中相应的条带计算一个逐位奇偶校验，**奇偶校验位保存在奇偶校验磁盘相应的条带中**

​			RAID5:

​				RAID 5的组织类似于RAID 4，不同之处在于RAID 5把奇偶校验条带分布在所有磁盘中

​				奇偶校验条带分布在所有驱动器上，当一个磁盘发生损坏，数据可以由其他N-1个磁盘中恢复出来

### 5.7.1 块设备管理的主要数据结构

​		缓冲控制块buf

```
struct buf
	{
		int	b_flags;		/* 缓冲区标志，反映缓冲区的使用情况和I/O方式，如忙或闲、数据有效性、								“延迟写”、正在读/写、等待缓冲区空闲等 */
		struct buf *b_forw;	/* 设备队列前向指针 */
		struct buf *b_back;	/* 设备队列后向指针 */
		struct buf *av_forw;	/* 自由队列前向指针 */
		struct buf *av_back;	/* 自由队列后向指针 */
}
```

​		块设备表

​		块设备开关表

### 5.7.2 缓冲区管理

#### 	1.缓冲区管理队列

​		(1)自由buf队列	

​				系统把**空闲缓冲区的buf组成空闲buf队列，即自由buf队列**。这个队列是**双向链结构**；队首块为			bfreelist；av_forw和av_back作为该队列的双向指针

​		(2)设备buf队列

​				设备缓冲区队列连接**所有各类设备使用过的缓冲区**，这也是一个**双向队列**；头部为hbuf；buf中的			b_forw和b_back分别为该队列的前指针和后指针

​				**一个缓冲区被分配用于读、写某个设备的字符块时，其相应的buf就进入该设备的设备buf队列**，并**一			直保留**在该设备buf队列中，除非被移作它用。

​		(3)空设备队列**(未分配给指定设备)**

​				**当系统需要缓存，但它不与特定的设备字符块相关联时**，将分配到的缓存控制块buf送入NODEV队			列；队列控制块也是bfreelist；用的指针是b_forw和b_back

​		(4)设备I/O请求队列**(正在使用)**

​				每个块设备有一个设备I/O请求队列，单向连接，头部为iobuf，b_actf和b_actl分别指向队首和队尾

​		**四个队列所属缓冲区之间的关系总结**

​			 (1)**任何一个缓冲区在稳定的状态下，同时属于两个队列**。
​			 (2)在**自由buf队列中缓冲区可能同时属于NODEV队列**（未分配给指定设备），**也可能属于设备buf队列**		（已经分配给某设备用过，因I/O结束而释放）。
 			(3)在设备buf队列中的缓冲区，可能挂在自由buf队列（已用过被释放），也可能挂在设备I/O请求队列		（正在使用）。
 			(4)在NODEV队列中的缓冲区如已用过被释放，肯定在自由buf队列中。

### 			 (5)在**设备I/O请求队列中的缓冲区则肯定属于设备buf队列**。 

#### 	2.缓冲区管理算法：最久未使用算法LRU

​		(1)分配一个缓冲区时，系统从自由buf队首取出一个空闲buf，将buf的标志位b_flags设置为B_BUSY。此外，还要将其**从原设备buf队列中换入新设备buf队列**(如果是相同设备则不执行)。

​		由此一来,一个缓存刚分配用于读写某一块设备，buf的b_flags含有B_BUSY标志。它一定位于相应设备buf队列，不在自由队列。

​		(2)一旦读写完成，就释放缓存，清B_BUSY标志。**送入自由队列尾**，**但仍留在原设备队列**

​		对于写操作，如**一次写操作未写满缓冲区**，则在b_flags中设置B_DELWRI标志，设置为“**延迟写”**，再清B_BUSY，**挂在自由队列尾同时留在设备buf队列中**。

​		空闲缓冲区既在自由buf中又在原设备buf中的好处：

​			①一个缓存既在设备队列，又在自由队列，**只要还要重复使用原设备队列中该缓存内容，就只要简单地		将其从自由队列抽出即可**，避免了重复I/O。 

​			②有必要可将缓存重新分配它用，将它从自由队列首和原设备队列同时抽出，送入新的设备队列。操作		完成后仍留在新的设备队列并送入自由队列。 

## **6.   文件系统**

### 6.6.1 索引节点 I节点

```
struct dinode { 
    ushort       di_mode；        文件控制模式
    short        di_nlink；          文件的链接数
    char         di_addr[40]；    地址索引表，存放文件的盘块号
}
```

​		字符数组di_addr[40]中**每三个字节组成一个单元，以记录文件的盘块号**，构成了13个表项的地址索引表，将其设置成**40字节大小是为了使索引节点的大小为64字节，以便在一个盘块中正好放满整数个（对1K大小的盘块，可放16个）I节点**。

### 6.6.2 文件索引结构   

​		UNIX将这13个表项分成三种寻址方式

​		1.**直接寻址**

​				地址索引表中的前10个表项直接存放文件前10个逻辑块的物理盘块地址。

​		2.**一级间接寻址**

​			长度大于10个盘块的文件，其前10个盘块还是采用直接寻址方式，后面的盘块部分采用一级间接寻址方		式。也即在**地址索引表的第11个表项登记的不是文件的物理盘块号，而是一个索引块的地址**。

​			每个表项存放文件第10个逻辑块以后的物理盘块的地址采用这种索引方式的**文件大小为[1024/3]** = 341 K 		B ，与直寻址方式相加，文件最大长度为351KB

​		3.**二级间接寻址**

​			在地址索引表的第**12个表项中登记了一个具有341个表项的间接索引块地址，间接索引块的每一个表项又		各登记了一个具有341个表项的索引块地址**，在这级索引块中的表项才有存放文件的物理盘块地址。

​			单用二级间接索引就可访问341×341个文件物理块

​		4.三级间接寻址

​			单用三级间接寻址方式所能访问的物理盘块数为341×341×341块

​			四种寻址方式所能访问的文件最大长度为（10+341+341×341+341×341×341）KB，即近40G

​			文件的长度还要受I节点中记录文件长度的成员di_size的取值限制，di_size为32位的无符号长整型，这样		**文件的最大长度为232 byte = 4G**